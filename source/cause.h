#ifndef CAUSE
#define CAUSE

typedef struct {
        char *cs_t;
        char *cs_i;
} causeExplanation;

#define HELP_PICK1 "You have checked that the file exists, but lowercase and uppercase letters are an issue in Linux?\n"
#define HELP_PICK2 "* Linux filesystem is not free case-sensitive like Windows.\n"
#define HELP_PICK3 "** You need to fix it with renaming any files and folders in gamemodes/ and changing #include name to lowercase only.\n"
#define HELP_PICK4 "likely:\n   gamemodes\n   ├── main.pwn\n   └── TEST\n   └── test.inc\n"
#define HELP_PICK5 "- #include \"TEST.inc\" -> #include \"test.inc\"\n\n"
#define HELP_PICK6 "first: backup your \"gamemodes\" folder to \"swp_gamemodes\" and copy \"swp_gamemodes\" to \"gamemodes\"\n"
#define HELP_PICK7 "shell (bash) operation:\n"
#define HELP_PICK8 "linux native:\n"
#define HELP_PICK9 "   bash -c 'BASE=\"gamemodes\"; find \"$BASE\" -type f " \
"\\( -name \"*.pwn\" -o -name \"*.inc\" \\) -exec sed -i -E \"s|(#include[[:space:]]+\\\")([^\\\"]+)(\\\")|\\1\\L\\2\\3|g\" {} " \
"+ && find \"$BASE\" -depth | while IFS= read -r p; do [ \"$p\" = \"$BASE\" ] && continue; d=$(dirname \"$p\"); b=$(basename \"$p\" | " \
"tr \"A-Z\" \"a-z\"); [ \"$p\" != \"$d/$b\" ] && mv \"$p\" \"$d/$b\"; done'\n"
#define HELP_PICK01 "termux (android - please change the 'GAMEMODE_FOLDER_NAME' to folder name of your gamemode in downloads/):\n"
#define HELP_PICK02 "   bash -c 'BASE=\"../storage/downloads/GAMEMODE_FOLDER_NAME/gamemodes\"; " \
"find \"$BASE\" -type f \\( -name \"*.pwn\" -o -name \"*.inc\" \\) " \
"-exec sh -c \"for f; do perl -i -pe \\\"s/(#include\\\\\\\\s+\\\\\\\\\\\")" \
"([^\\\\\\\\\\\"]+)(\\\\\\\\\\\")/\\\\\\\\$1\\\\\\\\L\\\\\\\\$2\\\\\\\\$3/g\\\" \\\"\\\\\\\\$f\\\"; done\" sh {} + && " \
"find \"$BASE\" -depth | while IFS= read -r p; do [ -e \\\"$p\\\" ] && d=\\\\$(dirname \\\"$p\\\"); " \
"b=\\\\$(basename \\\"$p\\\" | tr \\\"A-Z\\\" \\\"a-z\\\"); [ \\\"$p\\\" != \\\"$d/$b\\\" ] && mv \\\"$p\\\" \\\"$d/$b\\\"; done'\n"

#define COMPILER_DT_PICK000001 "expected token"
#define COMPILER_DT_PICK000002 "only a single statement"
#define COMPILER_DT_PICK000003 "declaration of a local variable must appear in a compound block"
#define COMPILER_DT_PICK000012 "invalid function call, not a valid address"
#define COMPILER_DT_PICK000014 "invalid statement; not in switch"
#define COMPILER_DT_PICK000015 "default case must be the last case"
#define COMPILER_DT_PICK000016 "multiple defaults in switch"
#define COMPILER_DT_PICK000019 "not a label"
#define COMPILER_DT_PICK000020 "invalid symbol name"
#define COMPILER_DT_PICK000036 "empty statement"
#define COMPILER_DT_PICK000037 "missing semicolon"
#define COMPILER_DT_PICK000030 "unexpected end of file"
#define COMPILER_DT_PICK000027 "illegal character"
#define COMPILER_DT_PICK000026 "missing closing parenthesis"
#define COMPILER_DT_PICK000028 "missing closing bracket"
#define COMPILER_DT_PICK000054 "missing closing brace"
#define COMPILER_DT_PICK000004 "is not implemented"
#define COMPILER_DT_PICK000005 "function may not have arguments"
#define COMPILER_DT_PICK000006 "must be assigned to an array"
#define COMPILER_DT_PICK000007 "operator cannot be redefined"
#define COMPILER_DT_PICK000008 "must be a constant expression; assumed zero"
#define COMPILER_DT_PICK000009 "invalid array size"
#define COMPILER_DT_PICK000017 "undefined symbol"
#define COMPILER_DT_PICK000018 "initialization data exceeds declared size"
#define COMPILER_DT_PICK000022 "must be lvalue"
#define COMPILER_DT_PICK000023 "array assignment must be simple assignment"
#define COMPILER_DT_PICK000024 "break or continue is out of context"
#define COMPILER_DT_PICK000025 "function heading differs from prototype"
#define COMPILER_DT_PICK027 "invalid character constant"
#define COMPILER_DT_PICK000029 "invalid expression, assumed zero"
#define COMPILER_DT_PICK000032 "array index out of bounds"
#define COMPILER_DT_PICK000045 "too many function arguments"
#define COMPILER_DT_PICK000203 "symbol is never used"
#define COMPILER_DT_PICK000204 "symbol is assigned a value that is never used"
#define COMPILER_DT_PICK000205 "redundant code: constant expression is zero"
#define COMPILER_DT_PICK000209 "should return a value"
#define COMPILER_DT_PICK000211 "possibly unintended assignment"
#define COMPILER_DT_PICK000010 "invalid function or declaration"
#define COMPILER_DT_PICK000213 "tag mismatch"
#define COMPILER_DT_PICK000215 "expression has no effect"
#define COMPILER_DT_PICK000217 "loose indentation"
#define COMPILER_DT_PICK000234 "Function is deprecated"
#define COMPILER_DT_PICK000013 "no entry point"
#define COMPILER_DT_PICK000021 "symbol already defined"
#define COMPILER_DT_PICK028 "invalid subscript"
#define COMPILER_DT_PICK000033 "array must be indexed"
#define COMPILER_DT_PICK000034 "argument does not have a default value"
#define COMPILER_DT_PICK000035 "argument type mismatch"
#define COMPILER_DT_PICK037 "invalid string"
#define COMPILER_DT_PICK000039 "constant symbol has no size"
#define COMPILER_DT_PICK000040 "duplicate case label"
#define COMPILER_DT_PICK000041 "invalid ellipsis"
#define COMPILER_DT_PICK000042 "invalid combination of class specifiers"
#define COMPILER_DT_PICK000043 "character constant exceeds range"
#define COMPILER_DT_PICK000044 "positional parameters must precede"
#define COMPILER_DT_PICK000046 "unknown array size"
#define COMPILER_DT_PICK000047 "array sizes do not match"
#define COMPILER_DT_PICK000048 "array dimensions do not match"
#define COMPILER_DT_PICK000049 "invalid line continuation"
#define COMPILER_DT_PICK000050 "invalid range"
#define COMPILER_DT_PICK000055 "start of function body without function header"
#define COMPILER_DT_PICK000100 "cannot read from file"
#define COMPILER_DT_PICK000101 "cannot write to file"
#define COMPILER_DT_PICK000102 "table overflow"
#define COMPILER_DT_PICK000103 "insufficient memory"
#define COMPILER_DT_PICK000104 "invalid assembler instruction"
#define COMPILER_DT_PICK000105 "numeric overflow"
#define COMPILER_DT_PICK000107 "too many error messages on one line"
#define COMPILER_DT_PICK000108 "codepage mapping file not found"
#define COMPILER_DT_PICK000109 "invalid path"
#define COMPILER_DT_PICK000110 "assertion failed"
#define COMPILER_DT_PICK000111 "user error"
#define COMPILER_DT_PICK214 "literal array/string passed to non-const parameter"
#define COMPILER_DT_PICK000200 "is truncated to"
#define COMPILER_DT_PICK000201 "redefinition of constant"
#define COMPILER_DT_PICK000202 "number of arguments does not match"
#define COMPILER_DT_PICK000206 "redundant test: constant expression is non-zero"
#define COMPILER_DT_PICK214_2 "array argument was intended as const"
#define COMPILER_DT_PICK000060 "too many nested includes"
#define COMPILER_DT_PICK000061 "recursive include"
#define COMPILER_DT_PICK000062 "macro recursion too deep"
#define COMPILER_DT_PICK000068 "division by zero"
#define COMPILER_DT_PICK000069 "overflow in constant expression"
#define COMPILER_DT_PICK000070 "undefined macro"
#define COMPILER_DT_PICK000071 "missing preprocessor argument"
#define COMPILER_DT_PICK000072 "too many macro arguments"
#define COMPILER_DT_PICK038 "extra characters on line"

#define COMPILER_DT_SEL0000001 "A required syntactic element is missing from the parse tree. The parser expected one of: a semicolon ';', comma ',', closing parenthesis ')', bracket ']', or brace '}'. This typically indicates a malformed statement, improper expression termination, or incorrect nesting of control structures. Verify the statement's grammatical completeness according to Pawn's context-free grammar."
#define COMPILER_DT_SEL0000002 "The `case` label syntactic production permits exactly one statement as its immediate successor. For multiple statements, you must encapsulate them within a compound statement delimited by braces `{ ... }`. This restriction stems from Pawn's simplified switch statement implementation which avoids implicit block creation."
#define COMPILER_DT_SEL0000003 "Variable declarations within `case` or `default` labels require explicit scoping via compound blocks due to potential jump-to-label issues in the control flow graph. Without explicit braces, the variable's lifetime and scope cannot be properly determined, violating the language's static single assignment analysis."
#define COMPILER_DT_SEL0000012 "The identifier preceding the parenthesized argument list does not resolve to a function symbol in the current scope, or the call expression violates the function call syntax. Possible causes: attempting to call a non-function identifier, using incorrect call syntax for function pointers, or encountering a malformed expression that the parser misinterprets as a function call."
#define COMPILER_DT_SEL0000014 "The `case` or `default` labeled statement appears outside the lexical scope of any `switch` statement. These labels are context-sensitive productions that are only syntactically valid when nested within a switch statement's body according to Pawn's grammar specification section 6.8.1."
#define COMPILER_DT_SEL0000015 "The `default` label within a switch statement's case list must appear after all explicit `case` constant expressions. This ordering constraint is enforced by the Pawn Compiler's semantic analysis phase to ensure predictable control flow and to simplify the generated jump table implementation."
#define COMPILER_DT_SEL0000016 "A `switch` statement contains more than one `default` label, which creates ambiguous control flow. According to the language specification (ISO/IEC TR 18037:2008), each switch statement may have at most one default case to serve as the catch-all branch in the decision tree."
#define COMPILER_DT_SEL0000019 "The identifier following the `goto` keyword does not correspond to any labeled statement in the current function's scope. Label resolution occurs during the semantic analysis phase, and the target must be a label defined earlier in the same function body (forward jumps are permitted)."
#define COMPILER_DT_SEL0000020 "The identifier violates Pawn's lexical conventions for symbol names. Valid identifiers must match the regular expression: `[_@a-zA-Z][_@a-zA-Z0-9]*`. The '@' character has special significance for public/forward declarations and must be used consistently throughout the symbol's lifetime."
#define COMPILER_DT_SEL0000036 "A standalone semicolon constitutes a null statement, which Pawn's grammar specifically disallows in most contexts to prevent accidental emptiness. If intentional empty statement is needed, use an explicit empty block `{}`. Note that double semicolons `;;` often indicate a missing statement between them."
#define COMPILER_DT_SEL0000037 "A statement terminator (';') is required but absent. In Pawn's LL(1) grammar, semicolons terminate: expression statements, declarations, iteration statements, jump statements, and return statements. The parser's predictive parsing table expected this token to complete the current production."
#define COMPILER_DT_SEL0000030 "The lexical analyzer reached EOF while the parser was still expecting tokens to complete one or more grammatical constructs. Common causes: unclosed block comment `/*`, string literal without terminating quote, unmatched braces/parentheses/brackets, or incomplete function/control structure."
#define COMPILER_DT_SEL0000027 "The source character (codepoint) is not valid in the current lexical context. Outside of string literals and comments, Pawn only accepts characters from its valid character set (typically ASCII or the active codepage). Control characters (0x00-0x1F) except whitespace are generally illegal."
#define COMPILER_DT_SEL0000026 "An opening parenthesis '(' lacks its corresponding closing ')', creating an unbalanced delimiter sequence. This affects expression grouping, function call syntax, and condition specifications. The parser's delimiter stack detected this mismatch during syntax tree construction."
#define COMPILER_DT_SEL0000028 "An opening bracket '[' was not matched with a closing ']'. This affects array subscripting, array declarations, and sizeof expressions. The bracket matching algorithm in the parser's shift-reduce automaton failed to find a closing bracket before the relevant scope ended."
#define COMPILER_DT_SEL0000054 "An opening brace '{' lacks its corresponding closing '}'. This affects compound statements, initializer lists, and function bodies. The brace nesting counter in the lexical analyzer reached EOF without returning to zero, indicating structural incompleteness."
#define COMPILER_DT_SEL0000004 "A function prototype was declared (forward reference) but no corresponding definition appears in the translation unit. This may also indicate that the compiler's symbol table contains an unresolved external reference, possibly due to a previous function's missing closing brace causing the parser to incorrectly associate following code."
#define COMPILER_DT_SEL0000005 "The `main()` function, serving as the program entry point, must have signature `main()` with zero parameters. This restriction ensures consistent program initialization across all Pawn implementations and prevents ambiguity in startup argument passing conventions."
#define COMPILER_DT_SEL0000006 "String literals are rvalues of type 'array of char' and can only be assigned to compatible array types. The assignment operator's left operand must be an array lvalue with sufficient capacity (including null terminator). This is enforced during type checking of assignment expressions."
#define COMPILER_DT_SEL0000007 "Attempt to overload an operator that Pawn does not support for overloading. Only a specific subset of operators (typically arithmetic and comparison operators) can be overloaded via operator functions. Consult the language specification for the exhaustive list of overloadable operators."
#define COMPILER_DT_SEL0000008 "The context requires a compile-time evaluable constant expression but received a runtime expression. This affects: array dimension specifiers, case labels, bit-field widths, enumeration values, and preprocessor conditionals. The constant folder attempted evaluation but found variable references or non-constant operations."
#define COMPILER_DT_SEL0000009 "Array dimension specifier evaluates to a non-positive integer. Array sizes must be ≥1. For VLAs (Variable Length Arrays), the size expression must evaluate to positive at the point of declaration. This check occurs during array type construction in the type system."
#define COMPILER_DT_SEL0000017 "Identifier lookup in the current scope chain failed to find any declaration for this symbol. The compiler traversed: local block scope -> function scope -> file scope -> global scope. Possible causes: typographical error, missing include directive, symbol declared in excluded conditional compilation block, or incorrect namespace/visibility qualifiers."
#define COMPILER_DT_SEL0000018 "The initializer list contains more elements than the array's declared capacity. For aggregate initialization, the number of initializer-clauses must not exceed the array bound. For string literals, the literal length (including null terminator) must not exceed array size."
#define COMPILER_DT_SEL0000022 "The left operand of an assignment operator (=, +=, etc.) does not designate a modifiable location in storage. Valid lvalues include: variables, array subscript expressions, dereferenced pointers, and structure/union members. Constants, literals, and rvalue expressions cannot appear on the left of assignment."
#define COMPILER_DT_SEL0000023 "Arrays cannot be used with compound assignment operators due to the semantic complexity of element-wise operations. Only simple assignment '=' is permitted for array types, which performs memcpy-like behavior. For element-wise operations, explicit loops or functions must be used."
#define COMPILER_DT_SEL0000024 "A `break` statement appears outside any switch/loop construct, or `continue` appears outside any loop construct. These jump statements are context-sensitive and require specific enclosing syntactic structures. The control flow graph builder validates these constraints."
#define COMPILER_DT_SEL0000025 "Function definition signature does not match previous declaration in: return type, parameter count, parameter types (including qualifiers), or calling convention. This violates the one-definition rule and causes type incompatibility in the function type consistency check."
#define COMPILER_DT_SEL0000027_2 "Character constant syntax error: multiple characters in single quotes, unknown escape sequence, or numeric escape sequence out of valid range (0-255). Valid escape sequences are: \\a, \\b, \\e, \\f, \\n, \\r, \\t, \\v, \\\\, \\', \\\", \\xHH, \\OOO (octal)."
#define COMPILER_DT_SEL0000029 "The expression parser encountered syntactically valid but semantically meaningless construct, such as mismatched operator operands, incorrect operator precedence binding, or type-incompatible operations. The expression evaluator defaults to zero to allow continued parsing for additional error detection."
#define COMPILER_DT_SEL0000032 "Subscript expression evaluates to value outside array bounds [0, size-1]. This is a compile-time check for constant indices; runtime bounds checking depends on implementation. For multidimensional arrays, each dimension is checked independently."
#define COMPILER_DT_SEL0000045 "Function call contains more than 64 actual arguments, exceeding Pawn's implementation limit. This architectural constraint stems from the virtual machine's call frame design and register allocation scheme. Consider refactoring using structures or arrays for parameter groups."
#define COMPILER_DT_SEL0000203 "Variable, constant, or function declared but never referenced in any reachable code path. This may indicate: dead code, incomplete implementation, debugging remnants, or accidental omission. The compiler's data flow analysis determined no read operations on the symbol after its declaration."
#define COMPILER_DT_SEL0000204 "Variable receives a value (via assignment or initialization) that is subsequently never read. This suggests: unnecessary computation, redundant initialization, or logical error where the variable should be used but isn't. The live variable analysis tracks definitions and uses."
#define COMPILER_DT_SEL0000205 "Conditional expression in if/while/for evaluates to compile-time constant false (0), making the controlled block dead code. This often results from: macro expansion errors, contradictory preprocessor conditions, or logical errors in constant expressions. The constant folder detected this during control flow analysis."
#define COMPILER_DT_SEL0000209 "Non-void function reaches end of control flow without returning a value via return statement. All possible execution paths must return a value of compatible type. The control flow graph analyzer found at least one path terminating at function end without return."
#define COMPILER_DT_SEL0000211 "Assignment expression appears in boolean context where equality comparison is typical (e.g., if condition). The expression `if (a=b)` assigns b to a, then tests a's truth value. If comparison was intended, use `if (a == b)`. This heuristic warning triggers on assignment in conditional context."
#define COMPILER_DT_SEL0000010 "The parser expected a function declarator or variable declaration but encountered tokens that don't conform to declaration syntax. This can indicate: misplaced storage class specifiers, incorrect type syntax, missing identifier, or malformed parameter list. Verify the declaration follows Pawn's declaration syntax exactly."
#define COMPILER_DT_SEL0000213 "Type compatibility violation: expression type differs from expected type in assignment, argument passing, or return context. Pawn's tag system enforces type safety for numeric types. The type checker found incompatible tags between source and destination types."
#define COMPILER_DT_SEL0000215 "Expression statement computes a value but doesn't produce side effects or store result. Examples: `a + b;` or `func();` where func returns value ignored. This often indicates: missing assignment, incorrect function call, or leftover debug expression. The side-effect analyzer detected pure expression without observable effect."
#define COMPILER_DT_SEL0000217 "Inconsistent whitespace usage (spaces vs tabs, or varying indentation levels) detected. While syntactically irrelevant, inconsistent indentation impairs readability and may indicate structural misunderstandings. The lexer tracks column positions and detects abrupt indentation changes."
#define COMPILER_DT_SEL0000234 "Function marked with deprecated attribute via `forward deprecated:` or similar. Usage triggers warning but compiles. Deprecation suggests: API evolution, security concerns, performance issues, or planned removal. Consult documentation for replacement API."
#define COMPILER_DT_SEL0000013 "Translation unit lacks valid program entry point. Required: `main()` function or designated public function based on target environment. The linker/loader cannot determine startup address. Some environments allow alternative entry points via compiler options or specific pragmas."
#define COMPILER_DT_SEL0000021 "Redeclaration of identifier in same scope violates one-definition rule. Each identifier in a given namespace must have unique declaration (except for overloading, which Pawn doesn't support). The symbol table insertion failed due to duplicate key in current scope."
#define COMPILER_DT_SEL0000028_2 "Bracket operator applied to non-array type, or subscript expression has wrong type. Left operand must have array or pointer type, subscript must be integer expression. The type checker validates subscript expressions during expression evaluation."
#define COMPILER_DT_SEL0000033 "Array identifier used in value context without subscript. In most expressions, arrays decay to pointer to first element, but certain contexts require explicit element access. This prevents accidental pointer decay when element access was intended."
#define COMPILER_DT_SEL0000034 "Named argument syntax used with parameter that lacks default value specification. When calling with named arguments (`func(.param=value)`), all parameters without defaults must be explicitly provided. The argument binder cannot resolve missing required parameter."
#define COMPILER_DT_SEL0000035 "Actual argument type incompatible with formal parameter type. This includes: tag mismatch, array vs non-array, dimension mismatch for arrays, or value range issues. Function call type checking ensures actual arguments can be converted to formal parameter types."
#define COMPILER_DT_SEL0000037_2 "String literal malformed: unterminated (missing closing quote), contains invalid escape sequences, or includes illegal characters for current codepage. The lexer's string literal parsing state machine encountered unexpected input or premature EOF."
#define COMPILER_DT_SEL0000039 "`sizeof` operator applied to symbolic constant (enumeration constant, #define macro). `sizeof` requires type name or object expression with storage. Constants exist only at compile-time and have no runtime representation with measurable size."
#define COMPILER_DT_SEL0000040 "Multiple `case` labels in same switch statement have identical constant expression values. Each case must be distinct to ensure deterministic control flow. The switch statement semantic analyzer builds case value table and detects collisions."
#define COMPILER_DT_SEL0000041 "Array initializer with `...` (ellipsis) cannot determine appropriate array size. Ellipsis initializer requires either explicit array size or preceding explicit elements from which to extrapolate. The array initializer resolver failed to compute array dimension."
#define COMPILER_DT_SEL0000042 "Storage class specifiers combined illegally (e.g., `public static`, `forward native`). Each storage class has compatibility rules. The declaration specifier parser validates specifier combinations according to language grammar."
#define COMPILER_DT_SEL0000043 "Character constant numeric value outside valid 0-255 range (8-bit character set). Pawn uses unsigned 8-bit characters. Integer character constants, escape sequences, or multibyte characters must fit in 8 bits for portability across all Pawn implementations."
#define COMPILER_DT_SEL0000044 "In mixed argument passing, positional arguments appear after named arguments. Syntax requires all positional arguments first, then named arguments (`func(1, 2, .param=3)`). The parser's argument list processing enforces this ordering for unambiguous binding."
#define COMPILER_DT_SEL0000046 "Array declaration lacks size specifier and initializer, making size indeterminate. Array types must have known size at declaration time (except for extern incomplete arrays). The type constructor cannot create array type with unspecified bound."
#define COMPILER_DT_SEL0000047 "Array assignment between arrays of different sizes. For array assignment, source and destination must have identical size (number of elements). The type compatibility checker for assignment verifies array dimension equality."
#define COMPILER_DT_SEL0000048 "Array operation (arithmetic, comparison) between arrays of different dimensions. Element-wise operations require identical shape. The array operation validator checks dimension compatibility before generating element-wise code."
#define COMPILER_DT_SEL0000049 "Backslash-newline sequence appears outside valid context (preprocessor directive or string literal). Line continuation only permitted in: #define macros, #include paths, and string literals. The preprocessor's line splicing logic detected illegal continuation."
#define COMPILER_DT_SEL0000050 "Range expression (e.g., in enum or array initializer) malformed: `start .. end` where start > end, or values non-integral, or exceeds implementation limits. Range validator ensures start ≤ end and both are integer constant expressions."
#define COMPILER_DT_SEL0000055 "Compound statement `{ ... }` appears where function body expected but no preceding function declarator. This often indicates: missing function header, extra brace, or incorrect nesting. The parser's function definition production expects declarator before body."
#define COMPILER_DT_SEL0000100 "File I/O error opening or reading source file. Possible causes: file doesn't exist, insufficient permissions, path too long, file locked by another process, or disk/media error. The compiler's file layer returns system error which gets mapped to this message."
#define COMPILER_DT_SEL0000101 "Output file creation/write failure. Check: disk full, write protection, insufficient permissions, output directory doesn't exist, or file in use. The code generator's output routines failed to write compiled output."
#define COMPILER_DT_SEL0000102 "Internal compiler data structure capacity exceeded. Limits may include: symbol table entries, hash table chains, parse tree nodes, or string table size. Source code too large/complex for compiler's fixed-size internal tables. Consider modularization or compiler with larger limits."
#define COMPILER_DT_SEL0000103 "Dynamic memory allocation failed during compilation. The compiler's memory manager cannot satisfy allocation request due to system memory exhaustion or fragmentation. Source code may be too large, or compiler has memory leak."
#define COMPILER_DT_SEL0000104 "`#emit` directive contains unrecognized or illegal opcode/operand combination. The embedded assembler validates instruction against Pawn VM instruction set. Check opcode spelling, operand count, and operand types against VM specification."
#define COMPILER_DT_SEL0000105 "Numeric constant exceeds representable range for its type. Integer constants beyond 32-bit signed range, or floating-point beyond implementation limits. The constant parser's range checking detected value outside allowed bounds."
#define COMPILER_DT_SEL0000107 "Error reporting threshold exceeded for single source line. Prevents infinite error cascades from severely malformed code. Compiler stops processing this line after reporting maximum errors (typically 10-20)."
#define COMPILER_DT_SEL0000108 "Character set conversion mapping file specified via `-c` option missing or unreadable. The compiler needs this file for non-ASCII source character processing. Verify file exists in compiler directory or specified path."
#define COMPILER_DT_SEL0000109 "File system path syntax error or inaccessible directory component. Path may contain illegal characters, be too long, or refer to non-existent network resource. The compiler's path normalization routine rejected the path."
#define COMPILER_DT_SEL0000110 "Compile-time assertion via `#assert` directive evaluated false. Assertion condition must be constant expression; if false, compilation aborts. Used for validating compile-time assumptions about types, sizes, or configurations."
#define COMPILER_DT_SEL0000111 "`#error` directive encountered with diagnostic message. Intentionally halts compilation with custom error message. Used for conditional compilation checks, deprecated code paths, or unmet prerequisites."
#define COMPILER_DT_SEL0000214 "String literal or array initializer passed to function parameter not declared `const`. While syntactically valid, this risks modification of literal data which may be in read-only memory. Declare parameter as `const` if function doesn't modify data, or copy literal to mutable array first."
#define COMPILER_DT_SEL0000200 "Identifier exceeds implementation length limit (typically 31-63 characters). Excess characters ignored for symbol table purposes. This may cause collisions if truncated names become identical. Consider shorter, distinct names."
#define COMPILER_DT_SEL0000201 "Macro or `const` variable redefined with different value. The new definition overrides previous. This often occurs from conflicting header files or conditional compilation issues. If intentional, use `#undef` first or check inclusion order."
#define COMPILER_DT_SEL0000202 "Function call argument count differs from prototype parameter count. For variadic functions, minimum count must be satisfied. The argument count checker compares call site with function signature in symbol table."
#define COMPILER_DT_SEL0000206 "Condition always true at compile-time, making conditional redundant. Similar to warning 205 but for always-true conditions. May indicate: over-constrained condition, debug code left enabled, or macro expansion issue."
#define COMPILER_DT_SEL0000214_2 "Non-constant array argument passed to const-qualified parameter triggers this advisory. The function promises not to modify via const, but caller passes non-const. This is safe but suggests interface inconsistency."
#define COMPILER_DT_SEL0000060 "Include file nesting depth exceeds implementation limit (typically 50-100). May indicate: recursive inclusion, deep header hierarchies, or include loop. Use include guards (#ifndef) and forward declarations to reduce nesting."
#define COMPILER_DT_SEL0000061 "Circular include dependency detected. File A includes B which includes A (directly or indirectly). The include graph cycle detection prevents infinite recursion. Use include guards and forward declarations to break cycles."
#define COMPILER_DT_SEL0000062 "Macro expansion recursion depth limit exceeded. Occurs with recursively defined macros without termination condition. The preprocessor's macro expansion stack has safety limit to prevent infinite recursion."
#define COMPILER_DT_SEL0000068 "Constant expression evaluator encountered division/modulo by zero. Check: array sizes, case labels, enumeration values, or #if expressions. The constant folder performs arithmetic during preprocessing and catches this error."
#define COMPILER_DT_SEL0000069 "Arithmetic overflow during constant expression evaluation in preprocessor. Integer operations exceed 32-bit signed range. The preprocessor uses signed 32-bit arithmetic for constant expressions."
#define COMPILER_DT_SEL0000070 "Macro identifier used in `#if` or `#elif` not defined. Treated as 0 per C standard. May indicate: missing header, typo, or conditional compilation branch for undefined configuration. Use `#ifdef` or `#if defined()` to test existence."
#define COMPILER_DT_SEL0000071 "Function-like macro invoked with insufficient arguments. Each parameter in macro definition must correspond to actual argument. Check macro invocation against its definition parameter count."
#define COMPILER_DT_SEL0000072 "Function-like macro invoked with excess arguments beyond parameter list. Extra arguments are ignored but indicate likely error. Verify macro definition matches usage pattern."
#define COMPILER_DT_SEL0000038 "Trailing tokens after preprocessor directive. Preprocessor directives must occupy complete logical line (except line continuation). Common with stray semicolons or comments on `#include` lines."

void cause_compiler_expl(const char *log_file,const char *dog_output,int debug);    

#endif
